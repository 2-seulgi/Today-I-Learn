# 스프링 프레임워크 개요

스프링 프레임워크는 자바를 사용하는 애플리케이션을 지원하기 위한 종합적인 도구다. 이 프레임워크의 핵심은 특히 엔터프라이즈급 소프트웨어의 개발을 단순화하는 것으로, 인프라 지원을 제공하고 개발자가 애플리케이션의 비즈니스 로직 구축에 집중할 수 있도록 한다.

## 스프링 빈

- **정의**: 스프링 빈은 스프링 프레임워크의 제어 역전(IoC) 컨테이너가 관리하는 자바 객체다. 빈은 스프링을 사용하여 개발된 애플리케이션의 기반이 되며, 스프링 컨테이너 내에서 생성, 관리, 구성된다.

- **생성**: 자바 객체가 스프링 컨테이너에 빈으로 등록되면, 컨테이너가 해당 객체의 생성과 관리를 한다. 이는 빈의 생명주기 관리와 필요에 따른 빈의 구성을 포함한다.

- **사용**: 스프링 빈은 재사용 가능한 소프트웨어 구성 요소를 생성하는 데 사용된다. 이러한 빈은 데이터 모델, 서비스, 저장소 등을 나타낼 수 있다. 스프링 컨테이너에서 이러한 빈을 관리함으로써, 개발자는 애플리케이션의 다양한 부분을 쉽게 연결할 수 있어, 느슨한 결합과 높은 응집력을 줄 수 있다.

## 의존성 주입 (DI)

- **정의**: 의존성 주입은 객체가 그것의 의존성을 직접 생성하는 대신 외부로부터 제공받는 디자인 패턴이다. 스프링의 맥락에서 볼 때, IoC 컨테이너는 빈이 필요로 하는 의존성을 자동으로 생성하고 주입한다. 이는 개발자가 소스 코드에서 직접 인스턴스를 생성하고 의존성을 생성하는 대신에, 스프링 컨테이너가 미리 생성된 빈을 필요로 하는 객체에 주입한다는 의미.

- **원리**: 의존성 주입은 제어의 역전(IoC) 원칙의 한 형태로, 객체의 생성과 의존성 관리를 프로그래머가 아닌 프레임워크에 맡긴다.

  1. **생성자 주입(Constructor Injection)**: 생성자의 파라미터를 사용해서 객체 생성 시점에 모든 필수 의존성을 생성자를 통해 주입한다. 이 방법은 의존성이 명확하게 드러나고 변경 불가능한 객체를 만들때 유리하다.

  ```java
    @Service
    public class BookService {
        private final BookRepository repository;

        @Autowired
        public BookService(BookRepository repository) {
            this.repository = repository;
        }
    }
  ```

  2. **세터 주입(Setter Injection)**: 설정자 기반 의존성 주입이라고도 불린다. 객체 생성 후, 세터 메서드나 프로퍼티를 통해 의존성을 주입한다. 이 방법은 선택적 의존성이나 변경 가능한 의존성에 적합하다.

  ```java
    @Service
    public class BookService {
        private BookRepository repository;

        @Autowired
        public void setRepository(BookRepository repository) {
            this.repository = repository;
        }
    }
  ```

  3. **필드 주입(Field Injection)**: 클래스 필드에 @Autowired 어노테이션을 사용하여 객체의 필드에 직접 의존성을 주입한다. 코드는 간결해지지만, 의존성이 숨겨져 있어 테스트와 유지보수가 어렵다.

  ```java
  @Service
  public class BookService {

      @Autowired
      private BookRepository repository;
  }
  ```

다만, 스프링에서는 필드 기반보다 생성자 주입 방식을 권장한다. 이유는 다음과 같은데, 1. 객체가 생성되는 시점에 생성자를 호출하여 최소 1회만 주입하기 때문에 불변 객체를 보장 할 수 있다. 2. A객체에서 B객체를 참조하고, B에서 A를 참조하는 순환 참조를 방지 할 수 있다. 3. 단위 테스트를 작성할때 별도의 mocking처리 없이 테스트가 가능하다.

- **장점**: 의존성 주입은 코드의 결합도를 낮추고, 유지보수성 및 테스트 용이성을 향상시킨다. 또한, 애플리케이션 구성의 유연성을 증가시키며, 개발자가 비즈니스 로직에 더 집중할 수 있도록 돕는다.

## 제어의 역전 (IoC)

제어의 역전(IoC)은 현대 애플리케이션 개발, 특히 스프링과 같은 프레임워크에서 널리 사용되는 프로그래밍 원칙. 이 원칙은 코드를 통한 제어 흐름을 근본적으로 변경한다.

## 제어의 역전이란?

- **전통적인 제어 흐름**: 전통적인 프로그램에서는 코드(호출자)가 다른 코드(피호출자)를 직접 호출하고 제어한다. 객체를 명시적으로 생성하고, 그들의 메소드를 호출하며, 생명주기를 관리한다. 이 방법은 직관적이지만, 결합도가 높고 관리하기 어려운 코드로 이어질 수 있다.

- **제어의 역전**: IoC에서는 이 제어 흐름이 역전된다. 코드가 모든 것을 제어하는 대신, 프레임워크나 컨테이너가 클래스를 선택하고 인스턴스화하는 제어를 담당한다. 즉, 어떻게 해야 하는지를 정의하고, 프레임워크가 언제 어디서 할지를 결정한다.

## IoC의 작동법?

1. **의존성 주입**: 이는 IoC가 구현되는 일반적인 방법이다. 코드가 클래스의 객체를 생성하는 대신, 프레임워크가 실행 시간에 객체가 필요로 하는 의존성을 주입한다. 단지 의존성을 선언하고, 프레임워크가 이를 연결한다.

2. **이벤트 처리**: IoC의 또 다른 예는 이벤트 기반 프로그래밍이다. 이벤트(예: 버튼 클릭)에 대응하는 코드를 작성하고, 이벤트가 발생하면 실행 환경이 코드를 호출한다. 이벤트에 대해 무엇이 일어나야 하는지는 제어하지만, 이벤트가 언제 또는 어떻게 트리거되는지는 제어하지 않는다.

## IoC의 장점

- **결합도 감소**: 코드가 다른 모듈의 구현 세부 사항에 덜 의존하게 된다. 이는 변경과 관리를 더 쉽게 만든다.

- **유연성**: 구성 요소를 교체하거나 그 행동을 변경하는 것이 소비하는 코드를 건드리지 않고도 더 쉬워진다.

- **테스트 용이성**: 의존성이 주입되므로, 실제 구현을 모의 객체나 스텁으로 대체하기가 더 쉬워진다.

## 일상 생활에서의 예

스스로 식사를 준비하는 대신(전통적인 제어), 웨이터에게 원하는 것을 말하고(의존성 선언), 요리사가 식사를 준비합니다(요청을 처리하는 프레임워크). 식사가 어떻게 준비되는지 제어하지 않고, 단지 무엇을 해야 하는지를 제어한다. 이는 프로그래밍에서 IoC가 작동하는 방식이랑 같다. 즉 프로그램의 일부 제어를 프레임워크나 컨테이너에 넘겨 코드를 모듈화 하고 유연하며 관리하게 쉽게 만든다.

## AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)란?

AOP는 프로그래밍에서 공통적인 문제를 해결하는 방식 중 하나로, 애플리케이션의 주요 관심사와 횡단 관심사(크로스-커팅 컨선)를 분리하여 모듈성을 향상시키는 프로그래밍 패러다임이다. 이를 통해 코드의 재사용성을 높이고, 유지보수를 용이하게 한다

### 횡단 관심사(Cross-Cutting Concerns)란?

횡단 관심사는 애플리케이션의 여러 모듈이나 기능에 걸쳐 공통적으로 적용되어야 하는 기능이나 관심사이다. 이러한 관심사는 애플리케이션의 핵심 비즈니스 로직과는 직접적인 관련이 없지만, 애플리케이션을 올바르게 실행하기 위해 필수적으로 사용된다.

### 횡단 관심사의 예

- **로깅(Logging)**: 시스템의 동작 상태를 기록하여 추후 분석 가능하게 하게 함.
- **트랜잭션 관리(Transaction Management)**: 데이터베이스의 상태를 일관성 있게 유지하는데 필요한 로직을 처리함.
- **보안(Security)**: 애플리케이션의 보안 규칙을 적용하여 비인가 접근을 방지함.
- **오류 처리(Error Handling)**: 시스템의 오류를 적절히 처리하고 사용자에게 적절한 피드백을 제공함.

## AOP의 작동 원리

AOP는 `Aspect`라는 단위로 횡단 관심사를 정의(캡슐화)하고, 애플리케이션의 특정 지점(`Join Point` 즉, 실행포인트)에 이를 적용(`Advice`)한다. 이 과정에서 `Pointcut`을 사용하여 어떤 `Join Point`에 `Advice`를 적용할지 정의한다. `Weaving`은 이 모든 과정을 실제 코드에 적용하는 과정을 의미하고, 컴파일 시간 로드시간 또는 런타임에 발생한다.

## AOP의 필요성

AOP는 다음과 같은 이유로 필요하다 :

- **코드 중복 감소**: 횡단 관심사를 한 곳에 모아두어 비슷한 코드의 반복을 줄일 수 있다.
- **비즈니스 로직과 시스템 서비스의 분리**: AOP를 사용하면 비즈니스 로직을 깔끔하게 유지하면서 필요한 시스템 서비스(예: 트랜잭션 관리)를 분리할 수 있다.
- **유연성 및 유지보수성 향상**: 횡단 관심사를 중앙에서 관리함으로써 애플리케이션의 변경 사항이 발생할 때 쉽게 대응할 수 있다.
